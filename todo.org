* How to handle moving dragged block on hover
store a custom Maybe HoverState
  type alias HoverState = {
    hoveredDropBeacon : BeaconId,
    undoState : ModelRef (model)? (minus hoverstate)
  }

on mouse move, HoverState can:
  hover : Model -> BeaconId -> Model
    Nothing -> Just (hovered beacon, current model as undo state)
  unhover
    Just state -> Nothing (overwrite model with the undo state)
  changeHover
    Just state -> Just state (keep the same undo state)

when viewing lifeblocks
  check for if you're the dragged block, highlight somehow
  check for if one of your drop beacons is hovered
    if hovered, display the hypothetical merge, or the validation failure

custom drag state that includes hover state
  variants:
    not dragging
    dragging (but not hovering)
    hovering
  transitions:
    not dragging -> dragging
    dragging -> not dragging
    dragging -> hovering
      'push' undo state
    hovering -> dragging
      'pop' undo state
    hovering -> hovering
      keep undo state

* TODO get drag and drop working
** TODO i can drop other lifepaths before or after a benchblock
*** TODO need to implement move on drag vs copy on drag
should just go by the type of the beaconT; no change to draggable.js
'disable' the dragged block, but leave it in place
disable the whole slot it's from
*** TODO show the whole list in viewFragment
** TODO when dragging lifeblocks, do we move on pickup or on drop?
which is easier to understand?
which is easier to implement?
if move on pickup, need to store where to put it back
    (or just the old model? ie und
*** TODO consider changing from dropzones to drop range
how to display that?
highlight the place where it'll go on hover in some way
*** TODO validation?
** TODO split on drag
should be able to reorder a pair of lifepaths in a block
should be able to arbitrarily split off a new block
* TODO get a minimal version of the app running
  - [ ] sequentially picking lifepaths
    - [ ] get dnd working; able to drop first lifepath of a new block
    - [ ] easy search for allowed next lifepaths
  - [ ] think about a 'suggestions' endpoint
        send a character fragment in the request
        filter by:
          'i meet the requirements'
          'satisfies my unmet requirements'
        need to disallow born lifepaths on invalid character fragments
  - [ ] include skill roots in lifepath skills response
  - [ ] get google oauth flow working
  - [ ] integration tests for endpoint
  - [ ] unit tests for model
  - [ ] unit tests for json decoders


* TODO set up a deployment w/heroku or aws
** test that the app runs pending migrations on startup
** have a way to reset the book data/the db in general


* TODO think about how to handle stock common traits & born lifepaths
** need a table of common traits by stock?
** how to handle human cultural traits?
** and fey blood
*** implement skill restrictions as requiring the specific common trait

* TODO enter traits list
** need to handle stock common traits in a nice way

* TODO think about limits to put on the lifepath req table
** like depth/complexity
** should that just be a request validation rather than a constraint?

* TODO how do we ensure integrity of lifepath requirements?
** need a join table that duplicates which lps are referenced
in each other's json

* db changes
** TODO refactor check constraints into separate tables where possible
- [ ] year range
- [ ] stat mod & stat mod val pair
- [ ] find a nicer way to do skill roots
** TODO think about how to do appropriate weapons
*** treat it as any other skill until the point buy phase
**** also need to special case it for restrictions (ie counts as sword)
**** add a step to the process where they're forced to choose weapon skills to replace it
**** hardcode appropriate weapons into the specific skill restrictions
***** ie now it requires sword or app. weap.
** think about how to do lifepath requirements
*** store predicates as data
*** types of predicates:
**** and, or, any of
**** has specific lp, has specific trait
**** second lp, second or third lp
**** final age (thinker), current age (crazy old sailor)
**** lifepath from a setting (military order)
***** can't just list them, not good for user lifepath settings
**** specific trait (two parts)
***** they must have access to that trait
***** they must purchase that trait when actually making the character
**** a wife lifepath's husband lp (lady, dame)

* TODO have the app seed book data in a smart way
** add a 'migration' tracking table for book seeds?
  ie, diesel migration adds a todo list row to the seed table,
  then seed fn looks at that table

* TODO move the res calc constants to a repo module and make it private
** db_string method on ResCalc enum
** consider making these a database enum

* TODO rethink tools requirement type
** TODO weapon should be specific (arms, bow, etc)
** TODO musical instruments should get their own category
** TODO special categories like logistics/estate management
*** better to just have a generic tool description field?
*** might want to have a field to specify item id if/when there is such a thing
*** should leave tool requirement out of db for now?

* TODO are skills unique by name?
** torture changes based on if an orc takes it
*** for now, we're renaming the orc one
** user created stuff might need to be tied to a stock
*** multiple versions of sorcery, for example
*** we could have a user equivalent of a book?
**** this would make things a lot simpler
**** create a book for the user when they make their account
**** use the same schema for them as for the official stuff
**** allow creating multiple books #someday

* TODO how to do elven skill songs
** we could just put them in the skills table
*** will root
*** elves only (allowed by fey blood?)

* validations that need triggers
** leads should only point to settings in the same stock
** lifepath names should be unique within a stock
** list position for skills and traits should be contiguous
** think about changing the schema to fix these
** are triggers slow? fine for this project?
* TODO consider using diesel associations
** could simplify the leads/skill lists/trait lists stuff
** seems like there's some limitations:
   https://github.com/diesel-rs/diesel/issues/89
* TODO think of a better url for the filtered lifepath list endpoint
* TODO advisor to the court
  - [ ] add calculation rule option for general skill points
  - [ ] seeding needs to account for it existing 
        year range is 1-3; 10 res per year, 1 gsp per year
* TODO make the lifepaths repo return and log errors properly
** look into tracing or simple logger crates

* Soon (TM)
** TODO LifeBlock shouldn't get it's own module
** TODO TrackedBeacons should get its own module
** TODO static beacons shouldn't be confusable with draggables
** TODO find a better way to handle same lifepath in different settings
*** the diminishing returns rules care
*** for now, just have the diminishing returns do their own truncation
** TODO closest bounding beacon should go by distance/overlap
the whole point was to not do dropzones
** TODO benchblocks should be just a list of ids
ie normalize the model
** TODO handle the errors from draggable.js in decodeDragEvents
** TODO add on-hover text explaining the ui
** TODO add a util/common module with flipped dict lookup


