* TODO add more dwarf settings
** settings:
  - [ ] guilder
  - [ ] artificer
  - [ ] noble
  - [ ] host
  - [ ] outcast

* TODO enter skills list
* TODO enter traits list

* TODO add leads table (constraint for same stock?)
* TODO seed leads table
** lifepath id
** setting id
** look up settings by name & stock

* TODO think about replacing the seeding code with sql

* TODO think about how to handle stock common traits & born lifepaths
** need a table of common traits by stock?
** how to handle human cultural traits?
** and fey blood
*** implement skill restrictions as requiring the specific common trait

* db changes
** TODO think about how to do appropriate weapons
*** treat it as any other skill until the point buy phase
**** also need to special case it for restrictions (ie counts as sword)
**** add a step to the process where they're forced to choose weapon skills to replace it
**** hardcode appropriate weapons into the specific skill restrictions
***** ie now it requires sword or app. weap.
** think about a nice way to ensure list_position correctness (can't use check)
*** a trigger that checks if max list position is equal to count distinct?
*** are triggers slow? fine for this project?
** TODO make everything polymorphic on pageref vs user_id
** think about how to do lifepath requirements
*** store predicates as data
*** types of predicates:
**** and, or, any of
**** has specific lp, has specific trait
**** second lp, second or third lp
**** final age (thinker), current age (crazy old sailor)
**** lifepath from a setting (military order)
***** can't just list them, not good for user lifepath settings
**** specific trait (two parts)
***** they must have access to that trait
***** they must purchase that trait when actually making the character
**** a wife lifepath's husband lp (lady, dame)

* TODO set up a deployment w/heroku or aws
** test that the app runs pending migrations on startup
* TODO have the app seed book data in a smart way
** add a 'migration' tracking table for book seeds?
  ie, diesel migration adds a todo list row to the seed table,
  then seed fn looks at that table
* TODO find a way to seed the test database one time
** make a custom test runner
   https://doc.rust-lang.org/unstable-book/language-features/custom-test-frameworks.html
** recreate the test db once every time
** use diesel's test_transaction

* TODO move the HALF_PREVIOUS constant to a repo module and make it private
** db_string method on ResCalc enum
