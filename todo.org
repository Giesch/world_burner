* How to handle moving dragged block on hover
store a custom DragState
  variants:
    not dragging
      contains nothing?
    dragging (but not hovering)
      contains draggedBlock
    hovering
      constains draggedBlock and HoverState
  transitions:
    not dragging -> dragging
      add draggedBlock
    dragging -> not dragging
      remove draggedBlock
    dragging -> hovering
      add drop beacon
    hovering -> dragging
      remove drop beacon
    hovering -> hovering
      change drop beacon
    hovering -> not dragging
      on drop (valid or inavalid)

when viewing lifeblocks
  check for if you're the original dragged block
    highlight somehow
  check for if one of your drop beacons is hovered
    if hovered, display the appropriate thing
        new slot
        hypothetical merge
        validation failure

on drop
  if invalid, just go to not-dragging state
  if valid & sidebar block, do the merge or add the slot
  if valid & bench block, do the mrege or add the slot, and clean up the original

* TODO get basic drag and drop working
** DONE clean up the source lifeblock when it's dropped before/after its own slot
** TODO split on drag
should be able to arbitrarily split off a new block
should be able to reorder lifepaths within a block
* TODO drag and drop validation
** TODO validation in place
- [ ] missing lifepath requirement
- [ ] missing born lifepath
** TODO validation on hover
- [ ] missing setting lead
* TODO get a minimal version of the app running
  - [ ] sequentially picking lifepaths
    - [ ] get dnd working; able to drop first lifepath of a new block
    - [ ] easy search for allowed next lifepaths
  - [ ] think about a 'suggestions' endpoint
        send a character fragment in the request
        filter by:
          'i meet the requirements'
          'satisfies my unmet requirements'
        need to disallow born lifepaths on invalid character fragments
  - [ ] include skill roots in lifepath skills response
  - [ ] get google oauth flow working
  - [ ] integration tests for endpoint
  - [ ] unit tests for model
  - [ ] unit tests for json decoders


* TODO set up a deployment w/heroku or aws
** test that the app runs pending migrations on startup
** have a way to reset the book data/the db in general


* TODO think about how to handle stock common traits & born lifepaths
** need a table of common traits by stock?
** how to handle human cultural traits?
** and fey blood
*** implement skill restrictions as requiring the specific common trait

* TODO enter traits list
** need to handle stock common traits in a nice way

* TODO think about limits to put on the lifepath req table
** like depth/complexity
** should that just be a request validation rather than a constraint?

* TODO how do we ensure integrity of lifepath requirements?
** need a join table that duplicates which lps are referenced
in each other's json

* db changes
** TODO refactor check constraints into separate tables where possible
- [ ] year range
- [ ] stat mod & stat mod val pair
- [ ] find a nicer way to do skill roots
** TODO think about how to do appropriate weapons
*** treat it as any other skill until the point buy phase
**** also need to special case it for restrictions (ie counts as sword)
**** add a step to the process where they're forced to choose weapon skills to replace it
**** hardcode appropriate weapons into the specific skill restrictions
***** ie now it requires sword or app. weap.
** think about how to do lifepath requirements
*** store predicates as data
*** types of predicates:
**** and, or, any of
**** has specific lp, has specific trait
**** second lp, second or third lp
**** final age (thinker), current age (crazy old sailor)
**** lifepath from a setting (military order)
***** can't just list them, not good for user lifepath settings
**** specific trait (two parts)
***** they must have access to that trait
***** they must purchase that trait when actually making the character
**** a wife lifepath's husband lp (lady, dame)

* TODO have the app seed book data in a smart way
** add a 'migration' tracking table for book seeds?
  ie, diesel migration adds a todo list row to the seed table,
  then seed fn looks at that table

* TODO move the res calc constants to a repo module and make it private
** db_string method on ResCalc enum
** consider making these a database enum

* TODO rethink tools requirement type
** TODO weapon should be specific (arms, bow, etc)
** TODO musical instruments should get their own category
** TODO special categories like logistics/estate management
*** better to just have a generic tool description field?
*** might want to have a field to specify item id if/when there is such a thing
*** should leave tool requirement out of db for now?

* TODO are skills unique by name?
** torture changes based on if an orc takes it
*** for now, we're renaming the orc one
** user created stuff might need to be tied to a stock
*** multiple versions of sorcery, for example
*** we could have a user equivalent of a book?
**** this would make things a lot simpler
**** create a book for the user when they make their account
**** use the same schema for them as for the official stuff
**** allow creating multiple books #someday

* TODO how to do elven skill songs
** we could just put them in the skills table
*** will root
*** elves only (allowed by fey blood?)

* validations that need triggers
** leads should only point to settings in the same stock
** lifepath names should be unique within a stock
** list position for skills and traits should be contiguous
** think about changing the schema to fix these
** are triggers slow? fine for this project?
* TODO consider using diesel associations
** could simplify the leads/skill lists/trait lists stuff
** seems like there's some limitations:
   https://github.com/diesel-rs/diesel/issues/89
* TODO think of a better url for the filtered lifepath list endpoint
* TODO advisor to the court
  - [ ] add calculation rule option for general skill points
  - [ ] seeding needs to account for it existing 
        year range is 1-3; 10 res per year, 1 gsp per year
* TODO make the lifepaths repo return and log errors properly
** look into tracing or simple logger crates

* Soon (TM)
** TODO LifeBlock shouldn't get it's own module
** TODO TrackedBeacons should get its own module
** TODO static beacons shouldn't be confusable with draggables
** TODO find a better way to handle same lifepath in different settings
*** the diminishing returns rules care
*** for now, just have the diminishing returns do their own truncation
** TODO closest bounding beacon should go by distance/overlap
the whole point was to not do dropzones
** TODO benchblocks should be just a list of ids
ie normalize the model
** TODO handle the errors from draggable.js in decodeDragEvents
** TODO add on-hover text explaining the ui
** TODO add a util/common module with flipped dict lookup
** TODO use a static site generator and load the book lifepaths at build time
** TODO do all filtering and searching of lifepaths on the client side
